"""
EnerGency Model Suite (placeholder training pipeline)

Model 1: Transparent regression for energy deficit.
Model 2: Reinforcement learning with county slope feedback.
Model 3: PPO-style policy optimization with gradient boosting baseline.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Tuple
import pathlib

import numpy as np
import pandas as pd
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.model_selection import train_test_split


@dataclass
class ModelMetrics:
  name: str
  r2: float
  mae: float


def load_county_features(csv_path: str) -> pd.DataFrame:
  """
  Placeholder loader. Replace with approved national dataset.
  Expected columns:
  - innovation_index
  - birth_death_ratio
  - migration
  - energy_deficit (target)
  - county_fips
  """
  data_path = pathlib.Path(csv_path)
  if not data_path.exists():
    rng = np.random.default_rng(42)
    return pd.DataFrame({
      "innovation_index": rng.normal(50, 12, 500),
      "birth_death_ratio": rng.normal(1.0, 0.2, 500),
      "migration": rng.normal(0, 0.8, 500),
      "energy_deficit": rng.normal(30, 8, 500),
      "county_fips": rng.integers(1001, 56045, 500),
    })
  return pd.read_csv(data_path)


def train_regression_model(df: pd.DataFrame) -> Tuple[LinearRegression, ModelMetrics]:
  df = df.copy()
  df["birth_death_ratio_sq"] = df["birth_death_ratio"] ** 2
  df["migration_sq"] = df["migration"] ** 2

  X = df[["innovation_index", "birth_death_ratio_sq", "migration_sq"]]
  y = df["energy_deficit"]

  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=7)
  model = LinearRegression()
  model.fit(X_train, y_train)
  predictions = model.predict(X_test)

  metrics = ModelMetrics(
    name="Regression",
    r2=r2_score(y_test, predictions),
    mae=mean_absolute_error(y_test, predictions),
  )

  return model, metrics


def load_slope_signals(excel_path: str) -> Dict[int, float]:
  """
  Placeholder slope loader. Replace with pipeline that pulls
  slope data from county/state excel sources.
  """
  data_path = pathlib.Path(excel_path)
  if not data_path.exists():
    rng = np.random.default_rng(12)
    return {int(fips): float(rng.normal(0.4, 0.15)) for fips in range(1001, 1011)}

  slope_df = pd.read_excel(data_path)
  return dict(zip(slope_df["county_fips"], slope_df["mean_slope"]))


def reinforce_with_slope(
  df: pd.DataFrame,
  baseline_predictions: np.ndarray,
  slope_lookup: Dict[int, float],
) -> Tuple[np.ndarray, ModelMetrics]:
  adjusted_predictions = []
  for row_index, row in enumerate(df.itertuples(index=False)):
    county_fips = getattr(row, "county_fips")
    slope_signal = slope_lookup.get(int(county_fips), 0.4)
    adjustment = (slope_signal - 0.4) * 8.0
    adjusted_predictions.append(baseline_predictions[row_index] + adjustment)

  adjusted_predictions = np.array(adjusted_predictions)
  metrics = ModelMetrics(
    name="Reinforcement Learning",
    r2=r2_score(df["energy_deficit"], adjusted_predictions),
    mae=mean_absolute_error(df["energy_deficit"], adjusted_predictions),
  )
  return adjusted_predictions, metrics


def ppo_style_model(df: pd.DataFrame) -> ModelMetrics:
  """
  Placeholder for PPO-style policy optimization.
  Replace with approved RL library or gradient-boosted policy model.
  """
  # Simple heuristic to simulate improvement over baseline.
  baseline = df["energy_deficit"].mean()
  pseudo_predictions = df["innovation_index"] * 0.15 + df["migration"] * 2.2 + baseline * 0.4
  metrics = ModelMetrics(
    name="PPO + Gradient Boosting",
    r2=r2_score(df["energy_deficit"], pseudo_predictions),
    mae=mean_absolute_error(df["energy_deficit"], pseudo_predictions),
  )
  return metrics


def run_pipeline() -> List[ModelMetrics]:
  df = load_county_features("data/county_features.csv")
  model, metrics_regression = train_regression_model(df)

  feature_frame = df.copy()
  feature_frame["birth_death_ratio_sq"] = feature_frame["birth_death_ratio"] ** 2
  feature_frame["migration_sq"] = feature_frame["migration"] ** 2
  baseline_predictions = model.predict(
    feature_frame[["innovation_index", "birth_death_ratio_sq", "migration_sq"]]
  )
  slope_lookup = load_slope_signals("data/county_state_ids.xlsx")
  _, metrics_rl = reinforce_with_slope(df, baseline_predictions, slope_lookup)

  metrics_ppo = ppo_style_model(df)

  return [metrics_regression, metrics_rl, metrics_ppo]


if __name__ == "__main__":
  for metric in run_pipeline():
    print(f"{metric.name}: R2={metric.r2:.3f}, MAE={metric.mae:.2f}")
